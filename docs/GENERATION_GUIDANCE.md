# Generation Guidance: Write Code That Passes Excelsior

When **writing or editing Python** in this repo, follow these patterns so Excelsior (and ruff, import-linter, mypy, pylint) find fewer violations. This is **proactive** guidance—use it during generation, not only when fixing after a failed check.

This file is generated by `excelsior init --guidance-only`. The canonical registry is in the package: `infrastructure/resources/rule_registry.yaml` keyed by `{linter}.{rule_code}`.

---

## Rule of the First Prompt

Never ask an AI to "implement X" without first asking it to **"Draft a Dependency Plan for X."** Define which **Layer** the code belongs in, which **Protocols** it will implement, and what **Infrastructure** it will touch—*before* writing logic.

## Negative Constraint List

- No direct imports of `libcst` in Domain. No top-level functions in UseCases. No use of `Any`.
- Domain has no I/O. UseCase receives dependencies via constructor injection.

## Protocol-First

When adding new behavior, define the Domain Protocol first, then implement in Infrastructure.

---

## Proactive guidance by rule

### excelsior

- **excelsior.F0002** (Pylint/astroid crash)
  Avoid passing non-string or invalid values to APIs that the linter infers from (e.g. qname). Use strings for qualified names.

- **excelsior.R0801** (Duplicated code detected across files)
  Avoid copy-pasting code. If logic is needed in multiple places, extract it to a common service or utility module.

- **excelsior.W9001** (Wrong dependency direction (e.g. Interface importing Infrastructure))
  Dependencies point inward. Domain has no external deps; UseCase/Interface depend on Domain; Infrastructure implements Domain protocols. Never let outer layers import inner implementation details.

- **excelsior.W9003** (Access to protected member)
  Do not access _protected members from outside the class. Use public API or add a use case that owns the interaction.

- **excelsior.W9004** (I/O or heavy dependency in Domain/UseCase)
  Domain and UseCase must not import infrastructure or do I/O. Define a Protocol in domain, implement in infrastructure, inject via constructor (dependency inversion).

- **excelsior.W9005** (Delegation anti-pattern)
  Avoid deep delegation chains. Prefer Strategy, Handler, or a single dispatch map.

- **excelsior.W9006** (Law of Demeter violation (chained access))
  Do not chain through objects (a.b.c.d). Call a method on the object you have; that method may call the next. One dot: friend.do_thing() not friend.thing.do_action().

- **excelsior.W9007** (Repository returning raw type instead of Entity)
  Repositories should return Domain entities, not raw infrastructure types.

- **excelsior.W9009** (Raw type used instead of Domain Entity)
  Use Domain entities and value objects, not raw infrastructure types.

- **excelsior.W9010** (God file (too many responsibilities))
  Keep files focused. One main responsibility per module; split large files by cohesive behavior.

- **excelsior.W9011** (Folder layout does not match layers)
  Organize code into domain, use_cases, interface, infrastructure. Keep layer boundaries clear.

- **excelsior.W9012** (Defensive None Check in wrong layer)
  Validation belongs in Interface layer. Do not check for None in Domain/UseCase.

- **excelsior.W9013** (I/O in wrong layer)
  I/O belongs in Infrastructure. Use Ports/Protocols and inject implementations.

- **excelsior.W9014** (UI/formatting in domain layer)
  Domain must not depend on UI. Use ports and inject renderers.

- **excelsior.W9015** (Missing type hint (Excelsior))
  Add type hints to every function and method. Use def f(x: int) -> str: and -> None for no return.

- **excelsior.W9016** (Use of Any type)
  Prefer concrete types over Any. Use Protocol, TypeVar, or domain types. Any disables type checking and hides bugs.

- **excelsior.W9017** (File not in layer map)
  All files in src/ must be mapped to an architectural layer.

- **excelsior.W9018** (Top-level functions not allowed)
  No top-level functions except in hard-wired allowlist (e.g. __main__.py).

- **excelsior.W9019** (External dependency without stubs)
  For untyped third-party libs, add stubs under stubs/<package>/ so the linter can resolve types. Use TYPE_CHECKING for optional imports.

- **excelsior.W9020** (Use of 'global' or module-level mutable state)
  State belongs in: (1) composition root / DI container for app-wide singletons, (2) instance attributes for per-object state, (3) explicit service/registry classes. Do not use the 'global' keyword or module-level mutable variables for application state.

- **excelsior.W9030** (Architectural entropy: same concept defined in multiple places)
  When adding a concept (rules, config, feature flags, etc.), define it in one place. All consumers read from that place. Do not add the same identifier to multiple files in definition contexts (list/set/dict of codes, symbols, etc.).

- **excelsior.W9032** (Per-method cyclomatic complexity exceeds threshold)
  Keep methods focused; extract logic into private helpers or domain functions to stay under the complexity threshold.

- **excelsior.W9033** (Protocol with too many methods (ISP violation))
  Keep protocols small; prefer several focused protocols over one large one.

- **excelsior.W9034** (Dependency typed to concrete class instead of Protocol)
  Dependencies via __init__; type to Protocol, not concrete class.

- **excelsior.W9035** (Bare except, except Exception without re-raise, or empty except body)
  Catch specific exceptions; re-raise or log and re-raise; never swallow with empty body.

- **excelsior.W9041** (Suggestion: __init__ with 6+ parameters (consider Builder))
  Group related parameters into a config object or use Builder for complex construction.

- **excelsior.W9042** (Suggestion: if/elif instantiating different classes (consider Factory))
  Use Factory when creation logic varies by condition.

- **excelsior.W9043** (Suggestion: if/elif selecting algorithms (consider Strategy))
  Inject strategy objects instead of branching on type or flag.

- **excelsior.W9044** (Suggestion: repeated conditionals on same state (consider State))
  Encapsulate state-specific behavior in state objects.

- **excelsior.W9045** (Suggestion: method calls 5+ dependencies (consider Facade))
  Group related operations behind a single facade when a method coordinates many dependencies.

- **excelsior.W9101** (Too many mocks in test)
  Prefer one Protocol stub over many mocks.

- **excelsior.W9102** (Testing private method)
  Test the public API, not private implementation details.

- **excelsior.W9201** (Infrastructure class not implementing Domain protocol)
  Every infrastructure adapter should implement a protocol defined in domain. Define the interface first, then implement.

- **excelsior.W9202** (Method has no implementation)
  Concrete methods must have implementation; abstract methods use @abstractmethod.

- **excelsior.W9301** (Direct instantiation of Infrastructure in UseCase)
  UseCase receives dependencies via __init__. Never call ConcreteClass() inside a use case; receive a Protocol and inject the implementation.

- **excelsior.W9501** (Bypass/suppression of rule)
  Do not suppress architectural rules. Fix the design so the violation does not occur.

- **excelsior.W9601** (Mutable domain entity)
  Domain entities should be immutable. Use @dataclass(frozen=True) or namedtuple. No attribute assignment after construction.

- **excelsior.clean-arch-import** (Domain importing outer layer)
  Domain must not import interface or infrastructure. Dependencies point inward only.

- **excelsior.clean-arch-protected** (Protected attribute exposure)
  Use _name for implementation details; expose via @property or methods when callers need access.

### import_linter

- **import_linter.contract** (Layer contract or import contract violated)
  Respect [tool.importlinter] contracts. Do not import from a layer that the contract forbids. Invert dependencies with Ports/Protocols in the allowed layer.

### mypy

- **mypy.arg-type** (Argument type incompatible with signature)
  Pass arguments whose types match the declared parameter types. Use cast() only when you know the runtime type is correct and mypy cannot infer it.

- **mypy.assignment** (Incompatible types in assignment)
  Annotate variables with the type you assign (e.g. x: str = 'hello'). Avoid assigning a value of one type to a variable annotated as another.

- **mypy.attr-defined** (Attribute not defined on type)
  Only access attributes that exist on the declared type. Add the attribute to the class or use a type that declares it.

- **mypy.import-not-found** (Module or import not found)
  Install missing dependencies or add stubs (e.g. stubs/<module>/). Use TYPE_CHECKING for optional imports where appropriate.

- **mypy.no-any-return** (Returning Any from function with concrete return type)
  Ensure the returned value is typed. If calling something that returns Any, annotate the result or narrow the type before returning.

- **mypy.no-redef** (Redefinition of name)
  Avoid redefining the same name in the same scope. Use a different name or restructure the code.

- **mypy.no-untyped-call** (Call to untyped function)
  Ensure callees have type annotations so mypy can check the call. Add types to the definition of the function being called.

- **mypy.no-untyped-def** (Function missing type annotations)
  Add type hints to every function: parameters and return type (use -> None for no return). Example: def f(x: int) -> str: ...

- **mypy.override** (Signature incompatible with supertype)
  When implementing a protocol or overriding a method, match the supertype's signature exactly (parameter names, types, return type).

- **mypy.return-value** (Return value incompatible with return type)
  Return values must match the declared return type. Update the annotation or the implementation so they align.

- **mypy.type-arg** (Missing type parameters for generic type)
  When using generics (list, dict, Optional, etc.), always supply type parameters (e.g. dict[str, int], list[str]). Avoid bare dict, list, Optional without type args.

- **mypy.union-attr** (Attribute access on Union type)
  Narrow Union types with isinstance() or other type guards before accessing type-specific attributes.

- **mypy.valid-type** (Invalid use as a type)
  Use types from typing (e.g. List, Dict) or built-in generics (list, dict) correctly. Do not use runtime values (e.g. any) as type annotations.

- **mypy.var-annotated** (Variable needs type annotation)
  Annotate variables when their type is not obvious from the initializer (e.g. my_var: list[str] = []). Use explicit annotations for empty containers and complex types.

### ruff

- **ruff.ARG001** (Unused function argument)
  Remove arguments you do not use, or prefix with underscore (e.g. _request) to mark intentionally unused.

- **ruff.ARG002** (Unused method argument)
  Same as ARG001: remove or prefix with underscore for interface compliance (e.g. implementing a protocol).

- **ruff.B008** (Mutable default argument)
  Do not use mutable defaults (e.g. def f(x=[])). Use None and assign inside the function: def f(x=None): x = [] if x is None else x.

- **ruff.C901** (Cyclomatic complexity too high)
  Extract branches and loops into helper functions to keep complexity low per function.

- **ruff.I001** (Import order violation)
  Keep imports sorted: standard library first, then third-party, then local imports. Use `ruff check --fix` to automate this.

- **ruff.PLR0912** (Too many branches)
  Prefer early returns and dict/strategy dispatch over long if/elif chains.

- **ruff.PLR0913** (Too many arguments)
  Keep functions to a small number of arguments (e.g. <= 5). Group related parameters into a dataclass or config object.

- **ruff.UP045** (Use `X | Y` for type unions)
  Use the `X | Y` syntax for unions instead of `typing.Union` or `typing.Optional` when targeting Python 3.10+.

---

For the **exact prompt for a specific rule** when fixing a violation, use the registry key `{linter}.{rule_code}` (e.g. `mypy.type-arg`, `excelsior.W9006`).