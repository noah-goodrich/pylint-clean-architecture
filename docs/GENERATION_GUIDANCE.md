# Generation Guidance: Write Code That Passes Excelsior

When **writing or editing Python** in this repo, follow these patterns so Excelsior (and ruff, import-linter, mypy, pylint) find fewer violations. This is **proactive** guidance—use it during generation, not only when fixing after a failed check.

This file is generated by `excelsior generate-guidance`. The canonical registry is in the package: `infrastructure/resources/rule_registry.yaml` keyed by `{linter}.{rule_code}`.

---

## Rule of the First Prompt

Never ask an AI to "implement X" without first asking it to **"Draft a Dependency Plan for X."** Define which **Layer** the code belongs in, which **Protocols** it will implement, and what **Infrastructure** it will touch—*before* writing logic.

## Negative Constraint List

- No direct imports of `libcst` in Domain. No top-level functions except in allowlisted entry-point modules (e.g. `__main__.py`). No use of `Any`. No `global` or module-level mutable state; use DI or instance attributes.
- Domain has no I/O. UseCase receives dependencies via constructor injection.

## Protocol-First

When adding new behavior, define the Domain Protocol first, then implement in Infrastructure.

---

## Proactive guidance by rule

### excelsior

- **excelsior.F0002** (Pylint/astroid crash)
  Avoid passing non-string or invalid values to APIs that the linter infers from (e.g. qname). Use strings for qualified names.

- **excelsior.W9003** (Access to protected member)
  Do not access _protected members from outside the class. Use public API or add a use case that owns the interaction.

- **excelsior.W9005** (Delegation anti-pattern)
  Avoid deep delegation chains. Prefer Strategy, Handler, or a single dispatch map.

- **excelsior.W9006** (Law of Demeter violation (chained access))
  Do not chain through objects (a.b.c.d). Call a method on the object you have; that method may call the next. One dot: friend.do_thing() not friend.thing.do_action().

- **excelsior.W9010** (God file (too many responsibilities))
  Keep files focused. One main responsibility per module; split large files by cohesive behavior.

- **excelsior.W9015** (Missing type hint (Excelsior))
  Add type hints to every function and method. Use def f(x: int) -> str: and -> None for no return.

- **excelsior.W9016** (Use of Any type)
  Prefer concrete types over Any. Use Protocol, TypeVar, or domain types. Any disables type checking and hides bugs.

- **excelsior.W9019** (External dependency without stubs)
  For untyped third-party libs, add stubs under stubs/<package>/ so the linter can resolve types. Use TYPE_CHECKING for optional imports.

- **excelsior.W9601** (Mutable domain entity)
  Domain entities should be immutable. Use @dataclass(frozen=True) or namedtuple. No attribute assignment after construction.

- **excelsior.banned-any-usage** (Use of Any type)
  Prefer concrete types over Any. Use Protocol, TypeVar, or domain types. Any disables type checking and hides bugs.

- **excelsior.clean-arch-bypass** (Bypass/suppression of rule)
  Do not suppress architectural rules. Fix the design so the violation does not occur.

- **excelsior.clean-arch-delegation** (Delegation anti-pattern)
  Avoid deep delegation chains. Prefer Strategy, Handler, or a single dispatch map.

- **excelsior.clean-arch-demeter** (Law of Demeter violation (chained access))
  Do not chain through objects (a.b.c.d). Call a method on the object you have; that method may call the next. One dot: friend.do_thing() not friend.thing.do_action().

- **excelsior.clean-arch-dependency** (Wrong dependency direction (e.g. Interface importing Infrastructure))
  Dependencies point inward. Domain has no external deps; UseCase/Interface depend on Domain; Infrastructure implements Domain protocols. Never let outer layers import inner implementation details.

- **excelsior.clean-arch-di** (Direct instantiation of Infrastructure in UseCase)
  UseCase receives dependencies via __init__. Never call ConcreteClass() inside a use case; receive a Protocol and inject the implementation.

- **excelsior.clean-arch-folder-structure** (Folder layout does not match layers)
  Organize code into domain, use_cases, interface, infrastructure. Keep layer boundaries clear.

- **excelsior.clean-arch-god-file** (God file (too many responsibilities))
  Keep files focused. One main responsibility per module; split large files by cohesive behavior.

- **excelsior.clean-arch-import** (Domain importing outer layer)
  Domain must not import interface or infrastructure. Dependencies point inward only.

- **excelsior.clean-arch-layer** (File in wrong layer)
  Place code in the layer that matches its dependencies: domain (no I/O), use_cases (orchestration), interface (CLI/API), infrastructure (I/O, adapters).

- **excelsior.clean-arch-protected** (Protected attribute exposure)
  Use _name for implementation details; expose via @property or methods when callers need access.

- **excelsior.clean-arch-resources** (I/O or heavy dependency in Domain/UseCase)
  Domain and UseCase must not import infrastructure or do I/O. Define a Protocol in domain, implement in infrastructure, inject via constructor (dependency inversion).

- **excelsior.clean-arch-unstable-dep** (External dependency without stubs)
  For untyped third-party libs, add stubs under stubs/<package>/ so the linter can resolve types. Use TYPE_CHECKING for optional imports.

- **excelsior.clean-arch-no-global-state** / **excelsior.W9020** (Use of `global` or module-level mutable state)
  Do not use `global`. Manage state via dependency injection (constructor or composition root), instance attributes, or explicit service/registry classes. State belongs in the composition root or on instances, not in module-level mutable variables.

- **excelsior.clean-arch-visibility** (Access to protected member)
  Do not access _protected members from outside the class. Use public API or add a use case that owns the interaction.

- **excelsior.contract-integrity-violation** (Infrastructure class not implementing Domain protocol)
  Every infrastructure adapter should implement a protocol defined in domain. Define the interface first, then implement.

- **excelsior.domain-immutability-violation** (Mutable domain entity)
  Domain entities should be immutable. Use @dataclass(frozen=True) or namedtuple. No attribute assignment after construction.

- **excelsior.missing-type-hint** (Missing type hint)
  Add type hints to every function and method. Use def f(x: int) -> str: and -> None for no return.

### import_linter

- **import_linter.contract** (Layer contract or import contract violated)
  Respect [tool.importlinter] contracts. Do not import from a layer that the contract forbids. Invert dependencies with Ports/Protocols in the allowed layer.

### mypy

- **mypy.arg-type** (Argument type incompatible with signature)
  Pass arguments whose types match the declared parameter types. Use cast() only when you know the runtime type is correct and mypy cannot infer it.

- **mypy.assignment** (Incompatible types in assignment)
  Annotate variables with the type you assign (e.g. x: str = 'hello'). Avoid assigning a value of one type to a variable annotated as another.

- **mypy.attr-defined** (Attribute not defined on type)
  Only access attributes that exist on the declared type. Add the attribute to the class or use a type that declares it.

- **mypy.import-not-found** (Module or import not found)
  Install missing dependencies or add stubs (e.g. stubs/<module>/). Use TYPE_CHECKING for optional imports where appropriate.

- **mypy.no-any-return** (Returning Any from function with concrete return type)
  Ensure the returned value is typed. If calling something that returns Any, annotate the result or narrow the type before returning.

- **mypy.no-redef** (Redefinition of name)
  Avoid redefining the same name in the same scope. Use a different name or restructure the code.

- **mypy.no-untyped-call** (Call to untyped function)
  Ensure callees have type annotations so mypy can check the call. Add types to the definition of the function being called.

- **mypy.no-untyped-def** (Function missing type annotations)
  Add type hints to every function: parameters and return type (use -> None for no return). Example: def f(x: int) -> str: ...

- **mypy.override** (Signature incompatible with supertype)
  When implementing a protocol or overriding a method, match the supertype's signature exactly (parameter names, types, return type).

- **mypy.return-value** (Return value incompatible with return type)
  Return values must match the declared return type. Update the annotation or the implementation so they align.

- **mypy.type-arg** (Missing type parameters for generic type)
  When using generics (list, dict, Optional, etc.), always supply type parameters (e.g. dict[str, int], list[str]). Avoid bare dict, list, Optional without type args.

- **mypy.union-attr** (Attribute access on Union type)
  Narrow Union types with isinstance() or other type guards before accessing type-specific attributes.

- **mypy.valid-type** (Invalid use as a type)
  Use types from typing (e.g. List, Dict) or built-in generics (list, dict) correctly. Do not use runtime values (e.g. any) as type annotations.

- **mypy.var-annotated** (Variable needs type annotation)
  Annotate variables when their type is not obvious from the initializer (e.g. my_var: list[str] = []). Use explicit annotations for empty containers and complex types.

### ruff

- **ruff.ARG001** (Unused function argument)
  Remove arguments you do not use, or prefix with underscore (e.g. _request) to mark intentionally unused.

- **ruff.ARG002** (Unused method argument)
  Same as ARG001: remove or prefix with underscore for interface compliance (e.g. implementing a protocol).

- **ruff.B008** (Mutable default argument)
  Do not use mutable defaults (e.g. def f(x=[])). Use None and assign inside the function: def f(x=None): x = [] if x is None else x.

- **ruff.C901** (Cyclomatic complexity too high)
  Extract branches and loops into helper functions to keep complexity low per function.

- **ruff.PLR0912** (Too many branches)
  Prefer early returns and dict/strategy dispatch over long if/elif chains.

- **ruff.PLR0913** (Too many arguments)
  Keep functions to a small number of arguments (e.g. <= 5). Group related parameters into a dataclass or config object.

---

For the **exact prompt for a specific rule** when fixing a violation, use the registry key `{linter}.{rule_code}` (e.g. `mypy.type-arg`, `excelsior.W9006`).