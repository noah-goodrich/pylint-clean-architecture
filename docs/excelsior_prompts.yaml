# Excelsior Prompt Registry
# Key: {linter}.{rule_code} â€” universal key for AI and tooling.
# manual_instructions: how to fix a violation (reactive).
# proactive_guidance: how to write code that avoids the violation (for generation).
# references: optional URLs.

# --- Mypy (type_integrity) ---
mypy.type-arg:
  short_description: "Missing type parameters for generic type"
  manual_instructions: "Add an explicit type annotation. Example: x: int = 1. Use typing.List, Dict, Optional, etc. when needed."
  proactive_guidance: "When using generics (list, dict, Optional, etc.), always supply type parameters (e.g. dict[str, int], list[str]). Avoid bare dict, list, Optional without type args."
  references: ["https://mypy.readthedocs.io/"]

mypy.arg-type:
  short_description: "Argument type incompatible with signature"
  manual_instructions: "Make the argument type match the function signature. Add a type cast (e.g. cast(...)) if the value is correct but mypy cannot infer it."
  proactive_guidance: "Pass arguments whose types match the declared parameter types. Use cast() only when you know the runtime type is correct and mypy cannot infer it."
  references: ["https://mypy.readthedocs.io/"]

mypy.return-value:
  short_description: "Return value incompatible with return type"
  manual_instructions: "Ensure the return value matches the declared return type. Fix the implementation or update the return type hint."
  proactive_guidance: "Return values must match the declared return type. Update the annotation or the implementation so they align."
  references: ["https://mypy.readthedocs.io/"]

mypy.assignment:
  short_description: "Incompatible types in assignment"
  manual_instructions: "Ensure the assigned value matches the variable's type. Change the value, add a cast, or fix the variable's annotation."
  proactive_guidance: "Annotate variables with the type you assign (e.g. x: str = 'hello'). Avoid assigning a value of one type to a variable annotated as another."
  references: ["https://mypy.readthedocs.io/"]

mypy.no-untyped-def:
  short_description: "Function missing type annotations"
  manual_instructions: "Add type annotations to all parameters and the return type. Example: def f(x: int) -> str: ..."
  proactive_guidance: "Add type hints to every function: parameters and return type (use -> None for no return). Example: def f(x: int) -> str: ..."
  references: ["https://mypy.readthedocs.io/"]

mypy.no-untyped-call:
  short_description: "Call to untyped function"
  manual_instructions: "The function being called lacks type annotations. Add types to that function's parameters and return value."
  proactive_guidance: "Ensure callees have type annotations so mypy can check the call. Add types to the definition of the function being called."
  references: ["https://mypy.readthedocs.io/"]

mypy.var-annotated:
  short_description: "Variable needs type annotation"
  manual_instructions: "Add a type annotation to the variable. Example: my_var: List[str] = []"
  proactive_guidance: "Annotate variables when their type is not obvious from the initializer (e.g. my_var: list[str] = []). Use explicit annotations for empty containers and complex types."
  references: ["https://mypy.readthedocs.io/"]

mypy.union-attr:
  short_description: "Attribute access on Union type"
  manual_instructions: "Use a type guard before accessing attributes. Example: if isinstance(x, Foo): x.bar  # mypy knows x is Foo here."
  proactive_guidance: "Narrow Union types with isinstance() or other type guards before accessing type-specific attributes."
  references: ["https://mypy.readthedocs.io/"]

mypy.attr-defined:
  short_description: "Attribute not defined on type"
  manual_instructions: "The attribute is not defined on the type. Check spelling, or add the attribute to the class definition."
  proactive_guidance: "Only access attributes that exist on the declared type. Add the attribute to the class or use a type that declares it."
  references: ["https://mypy.readthedocs.io/"]

mypy.valid-type:
  short_description: "Invalid use as a type"
  manual_instructions: "See Mypy docs: https://mypy.readthedocs.io/ Fix types at the reported location."
  proactive_guidance: "Use types from typing (e.g. List, Dict) or built-in generics (list, dict) correctly. Do not use runtime values (e.g. any) as type annotations."
  references: ["https://mypy.readthedocs.io/"]

mypy.override:
  short_description: "Signature incompatible with supertype"
  manual_instructions: "See Mypy docs: https://mypy.readthedocs.io/ Fix types at the reported location."
  proactive_guidance: "When implementing a protocol or overriding a method, match the supertype's signature exactly (parameter names, types, return type)."
  references: ["https://mypy.readthedocs.io/"]

mypy.no-redef:
  short_description: "Redefinition of name"
  manual_instructions: "See Mypy docs: https://mypy.readthedocs.io/ Fix types at the reported location."
  proactive_guidance: "Avoid redefining the same name in the same scope. Use a different name or restructure the code."
  references: ["https://mypy.readthedocs.io/"]

mypy.no-any-return:
  short_description: "Returning Any from function with concrete return type"
  manual_instructions: "See Mypy docs: https://mypy.readthedocs.io/ Fix types at the reported location."
  proactive_guidance: "Ensure the returned value is typed. If calling something that returns Any, annotate the result or narrow the type before returning."
  references: ["https://mypy.readthedocs.io/"]

mypy.import-not-found:
  short_description: "Module or import not found"
  manual_instructions: "See Mypy docs: https://mypy.readthedocs.io/ Fix types at the reported location."
  proactive_guidance: "Install missing dependencies or add stubs (e.g. stubs/<module>/). Use TYPE_CHECKING for optional imports where appropriate."
  references: ["https://mypy.readthedocs.io/"]

# Default for any other mypy code
mypy._default:
  short_description: "Mypy type error"
  manual_instructions: "See Mypy docs: https://mypy.readthedocs.io/ Fix types at the reported location."
  proactive_guidance: "Add or fix type annotations so types are consistent and mypy can verify the code."

# --- Ruff (code_quality / import_typing) ---
ruff.ARG001:
  short_description: "Unused function argument"
  manual_instructions: "Remove unused function argument or prefix with underscore (_arg) to indicate intentional non-use."
  proactive_guidance: "Remove arguments you do not use, or prefix with underscore (e.g. _request) to mark intentionally unused."
  references: ["https://docs.astral.sh/ruff/rules/"]

ruff.ARG002:
  short_description: "Unused method argument"
  manual_instructions: "Remove unused method argument or prefix with underscore"
  proactive_guidance: "Same as ARG001: remove or prefix with underscore for interface compliance (e.g. implementing a protocol)."

ruff.PLR0913:
  short_description: "Too many arguments"
  manual_instructions: "Reduce number of function arguments. Consider grouping related args into a dataclass/config object."
  proactive_guidance: "Keep functions to a small number of arguments (e.g. <= 5). Group related parameters into a dataclass or config object."
  references: ["https://docs.astral.sh/ruff/rules/"]

ruff.C901:
  short_description: "Cyclomatic complexity too high"
  manual_instructions: "Reduce cyclomatic complexity by extracting logic into smaller functions"
  proactive_guidance: "Extract branches and loops into helper functions to keep complexity low per function."

ruff.PLR0912:
  short_description: "Too many branches"
  manual_instructions: "Reduce number of branches. Consider early returns, lookup tables, or strategy pattern"
  proactive_guidance: "Prefer early returns and dict/strategy dispatch over long if/elif chains."

ruff.B008:
  short_description: "Mutable default argument"
  manual_instructions: "Move default mutable argument (list/dict) inside function body with 'if arg is None: arg = []'."
  proactive_guidance: "Do not use mutable defaults (e.g. def f(x=[])). Use None and assign inside the function: def f(x=None): x = [] if x is None else x."
  references: ["https://docs.astral.sh/ruff/rules/"]

ruff._default:
  short_description: "Ruff rule violation"
  manual_instructions: "See Ruff documentation: https://docs.astral.sh/ruff/rules/"
  proactive_guidance: "Follow Ruff's rule set for style and correctness; run ruff check and fix before committing."

# --- Excelsior (architectural) ---
excelsior.clean-arch-resources:
  short_description: "I/O or heavy dependency in Domain/UseCase"
  manual_instructions: "Move I/O (e.g. import astroid, file access) out of Domain/UseCase. Create a Domain protocol (interface) and implement it in Infrastructure. Inject the implementation via constructor."
  proactive_guidance: "Domain and UseCase must not import infrastructure or do I/O. Define a Protocol in domain, implement in infrastructure, inject via constructor (dependency inversion)."
  references: ["docs/ARCHITECTURE_ONBOARDING.md"]

excelsior.clean-arch-demeter:
  short_description: "Law of Demeter violation (chained access)"
  manual_instructions: "Manual architectural change required. Extract this chain into a delegated method on the immediate dependency to preserve encapsulation. Do not use temporary variables as a workaround - this is a linter cheat that bypasses the architectural issue."
  proactive_guidance: "Do not chain through objects (a.b.c.d). Call a method on the object you have; that method may call the next. One dot: friend.do_thing() not friend.thing.do_action()."
  references: ["docs/ARCHITECTURE_ONBOARDING.md", "RULES.md"]

excelsior.W9006:
  short_description: "Law of Demeter violation (chained access)"
  manual_instructions: "Manual architectural change required. Extract this chain into a delegated method on the immediate dependency to preserve encapsulation. Do not use temporary variables as a workaround - this is a linter cheat that bypasses the architectural issue."
  proactive_guidance: "Do not chain through objects (a.b.c.d). Call a method on the object you have; that method may call the next. One dot: friend.do_thing() not friend.thing.do_action()."
  references: ["docs/ARCHITECTURE_ONBOARDING.md", "RULES.md"]

excelsior.clean-arch-dependency:
  short_description: "Wrong dependency direction (e.g. Interface importing Infrastructure)"
  manual_instructions: "Infrastructure must not be imported by Interface (or similar). Invert: define a Port/Protocol in Domain, implement in Infrastructure, inject into Interface."
  proactive_guidance: "Dependencies point inward. Domain has no external deps; UseCase/Interface depend on Domain; Infrastructure implements Domain protocols. Never let outer layers import inner implementation details."
  references: ["docs/ARCHITECTURE_ONBOARDING.md"]

excelsior.domain-immutability-violation:
  short_description: "Mutable domain entity"
  manual_instructions: "Use @dataclass(frozen=True) or namedtuple for Domain types. Run 'excelsior fix' for auto-freeze where applicable."
  proactive_guidance: "Domain entities should be immutable. Use @dataclass(frozen=True) or namedtuple. No attribute assignment after construction."
  references: ["RULES.md"]

excelsior.W9601:
  short_description: "Mutable domain entity"
  manual_instructions: "Use @dataclass(frozen=True) or namedtuple for Domain types. Run 'excelsior fix' for auto-freeze where applicable."
  proactive_guidance: "Domain entities should be immutable. Use @dataclass(frozen=True) or namedtuple. No attribute assignment after construction."
  references: ["RULES.md"]

excelsior.banned-any-usage:
  short_description: "Use of Any type"
  manual_instructions: "Replace 'Any' with a concrete type (e.g. astroid.nodes.NodeNG, or a Domain entity). Add proper type hints."
  proactive_guidance: "Prefer concrete types over Any. Use Protocol, TypeVar, or domain types. Any disables type checking and hides bugs."
  references: ["RULES.md"]

excelsior.W9016:
  short_description: "Use of Any type"
  manual_instructions: "Avoid 'Any'. Use specific types from typing or your domain. See banned-any-usage."
  proactive_guidance: "Prefer concrete types over Any. Use Protocol, TypeVar, or domain types. Any disables type checking and hides bugs."
  references: ["RULES.md"]

excelsior.clean-arch-visibility:
  short_description: "Access to protected member"
  manual_instructions: "Access to protected member. Use public interface or add a use case."
  proactive_guidance: "Do not access _protected members from outside the class. Use public API or add a use case that owns the interaction."
  references: ["RULES.md"]

excelsior.W9003:
  short_description: "Access to protected member"
  manual_instructions: "Access to protected member. Use public interface or add a use case."
  proactive_guidance: "Do not access _protected members from outside the class. Use public API or add a use case that owns the interaction."
  references: ["RULES.md"]

excelsior.clean-arch-delegation:
  short_description: "Delegation anti-pattern"
  manual_instructions: "Delegation anti-pattern. Use Strategy, Handler, or dict-based dispatch."
  proactive_guidance: "Avoid deep delegation chains. Prefer Strategy, Handler, or a single dispatch map."
  references: ["RULES.md"]

excelsior.W9005:
  short_description: "Delegation anti-pattern"
  manual_instructions: "Delegation anti-pattern. Use Strategy, Handler, or dict-based dispatch."
  proactive_guidance: "Avoid deep delegation chains. Prefer Strategy, Handler, or a single dispatch map."
  references: ["RULES.md"]

excelsior.clean-arch-god-file:
  short_description: "God file (too many responsibilities)"
  manual_instructions: "God file detected. Split into smaller modules by responsibility."
  proactive_guidance: "Keep files focused. One main responsibility per module; split large files by cohesive behavior."
  references: ["RULES.md"]

excelsior.W9010:
  short_description: "God file (too many responsibilities)"
  manual_instructions: "God file detected. Split into smaller modules by responsibility."
  proactive_guidance: "Keep files focused. One main responsibility per module; split large files by cohesive behavior."
  references: ["RULES.md"]

excelsior.clean-arch-layer:
  short_description: "File in wrong layer"
  manual_instructions: "Move file to the correct layer directory (domain, use_case, interface, infrastructure) based on dependencies and responsibility."
  proactive_guidance: "Place code in the layer that matches its dependencies: domain (no I/O), use_cases (orchestration), interface (CLI/API), infrastructure (I/O, adapters)."
  references: ["docs/ARCHITECTURE_ONBOARDING.md"]

excelsior.clean-arch-import:
  short_description: "Domain importing outer layer"
  manual_instructions: "Remove the violating import. Domain cannot import Infrastructure. Use dependency inversion (Protocol in Domain, impl in Infra)."
  proactive_guidance: "Domain must not import interface or infrastructure. Dependencies point inward only."
  references: ["docs/ARCHITECTURE_ONBOARDING.md"]

excelsior.clean-arch-di:
  short_description: "Direct instantiation of Infrastructure in UseCase"
  manual_instructions: "Use constructor injection. Pass dependencies in __init__; do not instantiate Infrastructure inside UseCase."
  proactive_guidance: "UseCase receives dependencies via __init__. Never call ConcreteClass() inside a use case; receive a Protocol and inject the implementation."
  references: ["docs/ARCHITECTURE_ONBOARDING.md"]

excelsior.W9015:
  short_description: "Missing type hint (Excelsior)"
  manual_instructions: "Add explicit type hints to all parameters and return type. See .agent/instructions.md and RULES.md for examples."
  proactive_guidance: "Add type hints to every function and method. Use def f(x: int) -> str: and -> None for no return."
  references: ["RULES.md"]

excelsior.missing-type-hint:
  short_description: "Missing type hint"
  manual_instructions: "Add type hints to the reported element. Examples: def f(x: int) -> str: ...; __init__(self) -> None: ...; Use typing.List, Dict, Optional etc. where needed."
  proactive_guidance: "Add type hints to every function and method. Use def f(x: int) -> str: and -> None for no return."
  references: ["RULES.md"]

excelsior.F0002:
  short_description: "Pylint/astroid crash"
  manual_instructions: "Pylint/astroid crash. Ensure types passed to inference (e.g. qname) are strings. Report reproducible cases to the plugin repo."
  proactive_guidance: "Avoid passing non-string or invalid values to APIs that the linter infers from (e.g. qname). Use strings for qualified names."
  references: []

excelsior.contract-integrity-violation:
  short_description: "Infrastructure class not implementing Domain protocol"
  manual_instructions: "Class in Infrastructure must implement a Domain protocol. Define a Protocol in the domain layer, then make the class inherit it."
  proactive_guidance: "Every infrastructure adapter should implement a protocol defined in domain. Define the interface first, then implement."
  references: ["docs/ARCHITECTURE_ONBOARDING.md"]

excelsior.clean-arch-bypass:
  short_description: "Bypass/suppression of rule"
  manual_instructions: "Remove bypass comments. Fix the underlying violation instead of suppressing."
  proactive_guidance: "Do not suppress architectural rules. Fix the design so the violation does not occur."
  references: ["RULES.md"]

excelsior.clean-arch-protected:
  short_description: "Protected attribute exposure"
  manual_instructions: "Make the attribute private (_name) or expose via @property."
  proactive_guidance: "Use _name for implementation details; expose via @property or methods when callers need access."

excelsior.clean-arch-folder-structure:
  short_description: "Folder layout does not match layers"
  manual_instructions: "Adjust folder layout to match Clean Architecture layers. See .agent/instructions.md."
  proactive_guidance: "Organize code into domain, use_cases, interface, infrastructure. Keep layer boundaries clear."
  references: ["docs/ARCHITECTURE_ONBOARDING.md"]

excelsior.clean-arch-unstable-dep:
  short_description: "External dependency without stubs"
  manual_instructions: "Create stubs/<module>.pyi for the external dependency so the linter can resolve types. Example: stubs/snowflake/connector.pyi for snowflake.connector."
  proactive_guidance: "For untyped third-party libs, add stubs under stubs/<package>/ so the linter can resolve types. Use TYPE_CHECKING for optional imports."
  references: ["RULES.md"]

excelsior.W9019:
  short_description: "External dependency without stubs"
  manual_instructions: "Create stubs/<module>.pyi for the external dependency so the linter can resolve types. Example: stubs/snowflake/connector.pyi for snowflake.connector."
  proactive_guidance: "For untyped third-party libs, add stubs under stubs/<package>/ so the linter can resolve types. Use TYPE_CHECKING for optional imports."
  references: ["RULES.md"]

excelsior._default:
  short_description: "Excelsior architectural violation"
  manual_instructions: "See .agent/instructions.md and RULES.md. Fix the underlying architectural violation; avoid bypasses."
  proactive_guidance: "Follow Clean Architecture: dependencies inward, domain has no I/O, use protocols and constructor injection. See docs/ARCHITECTURE_ONBOARDING.md."

# --- Import-Linter (contracts) ---
import_linter.contract:
  short_description: "Layer contract or import contract violated"
  manual_instructions: "Remove or refactor the import that breaks the contract. 1) Check pyproject.toml [tool.importlinter] for defined contracts. 2) Move the imported code to an allowed layer, or invert the dependency (e.g. use a Port). 3) Ensure the importing module lives in a layer that may depend on the imported module."
  proactive_guidance: "Respect [tool.importlinter] contracts. Do not import from a layer that the contract forbids. Invert dependencies with Ports/Protocols in the allowed layer."
  references: ["https://github.com/seddons/import-linter"]
