"""
Stub Authority: Load and query .pyi files. Stub-First, no nominal maps.

Search order:
  1. Bundled stubs shipped with the package (excelsior_architect/stubs/)
  2. Project stubs/ at project root (project-local, generated by stub_creator)

The bundled stubs provide type information for untyped dependencies (astroid,
libcst, snowflake, etc.) and are distributed alongside the main package.
"""

import ast
from pathlib import Path

from excelsior_architect.domain.protocols import StubAuthorityProtocol
from excelsior_architect.infrastructure.pyi_annotation import PyiAnnotationHelper


class StubAuthority(StubAuthorityProtocol):
    """
    Load and query .pyi files. No nominal guessing.
    Search: 1) bundled package stubs, 2) project stubs/
    """

    @staticmethod
    def _bundled_stubs_dir() -> Path:
        """Path to stubs bundled with the package."""
        return Path(__file__).resolve().parent.parent.parent / "stubs"

    def __init__(self, stubs_root: Path | None = None) -> None:
        """Initialize with optional explicit stubs root path.

        If not provided, will use bundled stubs and project stubs.
        """
        self._stubs_root = stubs_root

    def _find_stubs_dirs(self, project_root: str | None = None) -> list[Path]:
        """Find all stubs directories to search, in priority order.

        Priority:
        1. Explicit stubs_root from constructor (if provided)
        2. Bundled stubs shipped with the package
        3. Project stubs/ relative to project_root
        """
        dirs: list[Path] = []

        if self._stubs_root and self._stubs_root.is_dir():
            dirs.append(self._stubs_root)

        bundled = self._bundled_stubs_dir()
        if bundled.is_dir():
            dirs.append(bundled)

        if project_root:
            project_stubs = Path(project_root) / "stubs"
            if project_stubs.is_dir() and project_stubs not in dirs:
                dirs.append(project_stubs)

        return dirs

    def get_stub_path(
        self, module_name: str, project_root: str | None = None
    ) -> str | None:
        """
        Resolve a .pyi for a module. Returns path or None.

        Handles both single-file stubs (module.pyi) and package stubs (module/__init__.pyi).
        For submodules like astroid.nodes, checks:
          - stubs/astroid/nodes.pyi (submodule file)
          - stubs/astroid/nodes/__init__.pyi (submodule package)
        """
        stubs_dirs = self._find_stubs_dirs(project_root)
        if not stubs_dirs:
            return None

        parts = module_name.split(".")

        for stubs_dir in stubs_dirs:
            # Try as a single file: stubs/foo/bar/baz.pyi
            rel_path = "/".join(parts) + ".pyi"
            single_file = stubs_dir / rel_path
            if single_file.exists():
                return str(single_file)

            # Try as a package: stubs/foo/bar/baz/__init__.pyi
            pkg_init = stubs_dir / "/".join(parts) / "__init__.pyi"
            if pkg_init.exists():
                return str(pkg_init)

            # For submodules, also check parent package
            # e.g., astroid.nodes might be in stubs/astroid/__init__.pyi as re-exports
            if len(parts) > 1:
                parent_init = stubs_dir / parts[0] / "__init__.pyi"
                if parent_init.exists():
                    return str(parent_init)

        return None

    def get_attribute_type(
        self,
        module_name: str,
        class_name: str,
        attr_name: str,
        project_root: str | None = None,
    ) -> str | None:
        """
        Resolve an attribute's type from a .pyi. Returns qname (e.g. builtins.str)
        or None. When the requested module does not resolve, tries astroid.nodes
        once (handles re-exported types and mis-attributed builtins).
        """
        result = self._get_attribute_type_impl(
            module_name, class_name, attr_name, project_root
        )
        if result is not None:
            return result
        # Fallback: for astroid module (which re-exports from nodes), try nodes directly
        if module_name == "astroid":
            return self._get_attribute_type_impl(
                "astroid.nodes", class_name, attr_name, project_root
            )
        # Fallback: if the requested module did not resolve and we are not
        # already querying astroid.nodes, try the astroid stub (e.g. for
        # ClassDef/FunctionDef/NodeNG when module was wrong or missing).
        if module_name != "astroid.nodes":
            return self._get_attribute_type_impl(
                "astroid.nodes", class_name, attr_name, project_root
            )
        return None

    def _get_attribute_type_impl(
        self,
        module_name: str,
        class_name: str,
        attr_name: str,
        project_root: str | None = None,
    ) -> str | None:
        """Internal: resolve from one module. No fallbacks."""
        stub_path = self.get_stub_path(module_name, project_root)
        if not stub_path:
            return None
        try:
            with open(stub_path, encoding="utf-8") as f:
                tree = ast.parse(f.read())
        except (OSError, SyntaxError):
            return None
        return PyiAnnotationHelper.find_attr_in_ast(tree, class_name, attr_name)
